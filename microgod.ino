// #include <LiquidCrystal.h>

/*
MicroGod

A god-themed Arduboy clicker game
*/

// Definitions
#define DEBUG false

// Game state
#define TITLE     0
#define FIGHT   1
#define PLAY      2
#define GAMEMENU  3
#define NOTIFY    4
#define SAVEMENU  5

// Game power up
#define PRAYERS           0
#define PROPHETS          1
#define PREDICAMENTS      2
#define SACRED_WRITINGS   3
#define PRIESTS           4
#define TEMPLES           5
#define MARTHYRS          6
#define SAINTS            7

#define NOTIFICATION_DURATION 60
#define DOUBLE_DURATION 300

#define SAVEGAME_LOCATION 333

#define ARROW_LEFT  0
#define ARROW_DOWN  1
#define ARROW_RIGHT 2

#define DEITIES 3

#include <Arduboy2.h>
#include <EEPROM.h>
#include "Font4x6.h"

// make an instance of arduboy used for many functions
Arduboy2 arduboy;
// Extra font for menus and such
Font4x6 font4x6 = Font4x6();

// Graphics
// Arrows
const unsigned char PROGMEM arrow_right[] = {
0xff,0xff,0x7e,0x7e,0x3c,0x3c,0x18,0x18
};

const unsigned char PROGMEM arrow_right_mask[] = {
0xff,0xff,0x7e,0x7e,0x3c,0x3c,0x18,0x18
};

const unsigned char PROGMEM arrow_left[] = {
0x18,0x18,0x3c,0x3c,0x7e,0x7e,0xff,0xff
};

const unsigned char PROGMEM arrow_left_mask[] = {
0x18,0x18,0x3c,0x3c,0x7e,0x7e,0xff,0xff
};

const unsigned char PROGMEM arrow_down[] = {
0x03,0x0f,0x3f,0xff,0xff,0x3f,0x0f,0x03
};

const unsigned char PROGMEM arrow_down_mask[] = {
0x03,0x0f,0x3f,0xff,0xff,0x3f,0x0f,0x03
};

const unsigned char PROGMEM arrow_up[] = {
0xc0,0xf0,0xfc,0xff,0xff,0xfc,0xf0,0xc0
};

const unsigned char PROGMEM arrow_up_mask[] = {
0xc0,0xf0,0xfc,0xff,0xff,0xfc,0xf0,0xc0
};

// 1x6
const unsigned char PROGMEM bar[] = {
0x3f
};

const unsigned char PROGMEM bar_mask[] = {
0x3f
};

// Game elements

// faith sprite 16x16
const unsigned char PROGMEM faith_image[] = {
0x00,0x00,0x00,0xf0,0x08,0x64,0xf4,0xf2,0xf2,0xf4,0x64,0x08,0xf0,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0x0c,0x11,0x67,0x67,0x11,0x0c,0x03,0x00,0x00,0x00,0x00
};

const unsigned char PROGMEM faith_mask[] = {
0x00,0x00,0x00,0xf0,0xf8,0xfc,0xfc,0xfe,0xfe,0xfc,0xfc,0xf8,0xf0,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x03,0x0f,0x1f,0x7f,0x7f,0x1f,0x0f,0x03,0x00,0x00,0x00,0x00
};

const unsigned char PROGMEM faith_small_image[] = {
0x0c,0x32,0x4d,0xbd,0xbd,0x4d,0x32,0x0c
};


const unsigned char PROGMEM faith_small_mask[] = {
0x0c,0x32,0x4d,0xbd,0xbd,0x4d,0x32,0x0c
};

const unsigned char PROGMEM predicament_image[] = {
0xfe,0xab,0xab,0xab,0xef,0x7b,0x3f,0x00
};

const unsigned char PROGMEM predicament_mask[] = {
0xfe,0xab,0xab,0xab,0xef,0x7b,0x3f,0x00
};

const unsigned char PROGMEM sacred_image[] = {
0x00,0x3e,0x55,0x5d,0x57,0x55,0x5f,0x00
};

const unsigned char PROGMEM sacred_mask[] = {
0x00,0x3e,0x55,0x5d,0x57,0x55,0x5f,0x00
};

const unsigned char PROGMEM prophet_image[] = {
0x05,0x6f,0xf3,0x7b,0x73,0xfb,0x66,0x00
};

const unsigned char PROGMEM prophet_mask[] = {
0x05,0x6f,0xf3,0x7b,0x73,0xfb,0x66,0x00
};

const unsigned char PROGMEM priest_image[] = {
0x04,0x04,0x96,0xf7,0xf7,0xe5,0x84,0x00
};

const unsigned char PROGMEM priest_mask[] = {
0x04,0x04,0x96,0xf7,0xf7,0xe5,0x84,0x00
};

const unsigned char PROGMEM temple_image[] = {
0xe3,0xdb,0xea,0x1b,0x1b,0xea,0xdb,0xe3
};

const unsigned char PROGMEM temple_mask[] = {
0xe3,0xdb,0xea,0x1b,0x1b,0xea,0xdb,0xe3
};

const unsigned char PROGMEM saint_image[] = {
0x0f,0x34,0xd6,0x7f,0x7f,0xd6,0x34,0x0f
};

const unsigned char PROGMEM saint_mask[] = {
0x0f,0x34,0xd6,0x7f,0x7f,0xd6,0x34,0x0f
};

const unsigned char PROGMEM marthyr_image[] = {
0x00,0x6c,0x3e,0x6e,0x2e,0x1e,0x1c,0x00
};

const unsigned char PROGMEM marthyr_mask[] = {
0x00,0x6c,0x3e,0x6e,0x2e,0x1e,0x1c,0x00
};

// God images (compressed)
// djinn.png  width: 64 height: 64
const PROGMEM uint8_t djinn[] = {
0x3f,0x3f,0xe0,0x28,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,0x0e,0x7f,0xce,0x39,
0xe7,0x9c,0x73,0x70,0xa8,0x73,0xce,0x39,0xe7,0x9d,0x73,0xce,0x39,0x1c,0x39,0xe7,
0x9c,0x73,0xce,0xe1,0x0f,0x0e,0x75,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0xbc,
0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9d,0x73,0xce,0x39,0xe7,0x9c,0x73,
0xce,0x39,0xef,0x9c,0x73,0xce,0x79,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,
0xc1,0x41,0xce,0x39,0xe7,0x9c,0xc3,0x91,0x73,0xce,0x39,0xe7,0x9d,0x73,0xce,0x39,
0x1c,0x39,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,0x0e,0x87,0xce,0x39,0xe7,0x9c,
0xe3,0x77,0xce,0x39,0xe7,0x9c,0x77,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x70,
0xc4,0xef,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0x3c,0x3b,0xe7,0x9c,0x73,
0xce,0x39,0xe7,0x9c,0x73,0x38,0x74,0xce,0x39,0xe7,0x9c,0x83,0x1f,0x9d,0x73,0xce,
0x39,0xe7,0xf0,0xeb,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0x87,0x63,0xe7,
0x9c,0x73,0xce,0xc1,0x4f,0xce,0x39,0xe7,0x9c,0x83,0x87,0x9c,0x73,0xce,0x39,0x3c,
0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0x70,0xa8,0x73,0xce,0x39,0xe7,0x9c,
0x73,0xce,0x39,0xe7,0xbc,0x73,0xce,0x39,0xe7,0xf0,0xe7,0x9c,0x73,0xce,0x39,0x38,
0x08
};
// bytes:225 ratio: 0.439

const PROGMEM uint8_t djinn_mask[] = {
0x3f,0x3f,0xe0,0x28,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,0x0e,0x7f,0xce,0x39,
0xe7,0x9c,0x73,0x70,0xa8,0x73,0xce,0x39,0xe7,0x9d,0x73,0xce,0x39,0x1c,0x39,0xe7,
0x9c,0x73,0xce,0xe1,0x0f,0x0e,0x75,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0xbc,
0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9d,0x73,0xce,0x39,0xe7,0x9c,0x73,
0xce,0x39,0xef,0x9c,0x73,0xce,0x79,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,
0xc1,0x41,0xce,0x39,0xe7,0x9c,0xc3,0x91,0x73,0xce,0x39,0xe7,0x9d,0x73,0xce,0x39,
0x1c,0x39,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,0x0e,0x87,0xce,0x39,0xe7,0x9c,
0xe3,0x77,0xce,0x39,0xe7,0x9c,0x77,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x70,
0xc4,0xef,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0x3c,0x3b,0xe7,0x9c,0x73,
0xce,0x39,0xe7,0x9c,0x73,0x38,0x74,0xce,0x39,0xe7,0x9c,0x83,0x1f,0x9d,0x73,0xce,
0x39,0xe7,0xf0,0xeb,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0x87,0x63,0xe7,
0x9c,0x73,0xce,0xc1,0x4f,0xce,0x39,0xe7,0x9c,0x83,0x87,0x9c,0x73,0xce,0x39,0x3c,
0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0x70,0xa8,0x73,0xce,0x39,0xe7,0x9c,
0x73,0xce,0x39,0xe7,0xbc,0x73,0xce,0x39,0xe7,0xf0,0xe7,0x9c,0x73,0xce,0x39,0x38,
0x08
};
// bytes:225 ratio: 0.439

// beholder.png  width: 64 height: 64
const PROGMEM uint8_t beholder[] = {
0x3f,0x3f,0x70,0xec,0x9c,0x73,0xce,0x79,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,
0x0e,0x47,0xce,0x39,0xe7,0x9c,0x77,0xce,0x39,0xe7,0xbc,0x73,0xce,0x39,0xe7,0x70,
0xe4,0x9c,0x73,0xce,0x79,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,0xde,0x39,0xe7,
0x9c,0xf3,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x77,0xce,0x39,0xe7,0xbc,
0x73,0xce,0x39,0xe7,0xf8,0x9d,0x73,0xce,0x39,0xe7,0xf8,0x9d,0x73,0xce,0x39,0xe7,
0x9d,0x73,0xce,0x39,0xc7,0xef,0x9c,0x73,0xce,0x39,0xc7,0xcf,0x8f,0x3f,0xe7,0x9c,
0x73,0xce,0xe1,0x08,0x47,0xce,0x39,0xe7,0x1c,0x0e,0x71,0xe4,0x9c,0x73,0xce,0xe1,
0x08,0xff,0xce,0x39,0xe7,0x9c,0x73,0x38,0x72,0xce,0x39,0xe7,0xbc,0x73,0xce,0x39,
0xe7,0x9d,0x73,0xce,0x39,0xc7,0xef,0x9c,0x73,0xce,0x39,0xef,0x9c,0x73,0xce,0xe1,
0x08,0x47,0xce,0x39,0xe7,0x9c,0xc3,0x9f,0x73,0xce,0x39,0xe7,0x1c,0x1c,0xe4,0x9c,
0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0xe1,0xd8,0x39,0xe7,0x9c,0x73,0xde,0x39,0xe7,
0x9c,0x73,0xce,0x39,0xe7,0x9c,0xf3,0xce,0x39,0xe7,0x1c,0x1e,0x9d,0x73,0xce,0x39,
0xe7,0x9c,0x73,0xce,0x39,0xef,0x9c,0x73,0xce,0x39,0x1c,0x39,0xe7,0x9c,0x73,0xce,
0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xde,0x39,0xe7,0x9c,0x73,0xce,0x39,
0xe7,0x9c,0xf3,0xce,0x39,0xe7,0x9c,0xc3,0xb1,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,
0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0xf0,0x8b,0x23,0xe7,0x9c,0x73,0xce,0x3b,0xe7,
0x9c,0x73,0xde,0x39,0xe7,0x9c,0xf3,0xce,0x39,0xe7,0x1c,0x8e,0x9c,0x73,0xce,0x39,
0x87,0x23,0xe7,0x9c,0x73,0xce,0x79,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,0xde,
0x39,0xe7,0x9c,0xf3,0xce,0x39,0xe7,0x9c,0x77,0xce,0x39,0xe7,0x70,0xe8,0x9c,0x73,
0xce,0x39,0xc7,0xef,0x9c,0x73,0xce,0x39,0x38,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,
0xe7,0x9c,0x73,0x0e,0x87,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x1c,0x1c,0x05
};
// bytes:336 ratio: 0.656

const PROGMEM uint8_t beholder_mask[] = {
0x3f,0x3f,0x70,0xec,0x9c,0x73,0xce,0x79,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,
0x0e,0x47,0xce,0x39,0xe7,0x9c,0x77,0xce,0x39,0xe7,0xbc,0x73,0xce,0x39,0xe7,0x70,
0xe4,0x9c,0x73,0xce,0x79,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,0xde,0x39,0xe7,
0x9c,0xf3,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x77,0xce,0x39,0xe7,0xbc,
0x73,0xce,0x39,0xe7,0xf8,0x9d,0x73,0xce,0x39,0xe7,0xf8,0x9d,0x73,0xce,0x39,0xe7,
0x9d,0x73,0xce,0x39,0xc7,0xef,0x9c,0x73,0xce,0x39,0xc7,0xcf,0x8f,0x3f,0xe7,0x9c,
0x73,0xce,0xe1,0x08,0x47,0xce,0x39,0xe7,0x1c,0x0e,0x71,0xe4,0x9c,0x73,0xce,0xe1,
0x08,0xff,0xce,0x39,0xe7,0x9c,0x73,0x38,0x72,0xce,0x39,0xe7,0xbc,0x73,0xce,0x39,
0xe7,0x9d,0x73,0xce,0x39,0xc7,0xef,0x9c,0x73,0xce,0x39,0xef,0x9c,0x73,0xce,0xe1,
0x08,0x47,0xce,0x39,0xe7,0x9c,0xc3,0x9f,0x73,0xce,0x39,0xe7,0x1c,0x1c,0xe4,0x9c,
0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0xe1,0xd8,0x39,0xe7,0x9c,0x73,0xde,0x39,0xe7,
0x9c,0x73,0xce,0x39,0xe7,0x9c,0xf3,0xce,0x39,0xe7,0x1c,0x1e,0x9d,0x73,0xce,0x39,
0xe7,0x9c,0x73,0xce,0x39,0xef,0x9c,0x73,0xce,0x39,0x1c,0x39,0xe7,0x9c,0x73,0xce,
0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xde,0x39,0xe7,0x9c,0x73,0xce,0x39,
0xe7,0x9c,0xf3,0xce,0x39,0xe7,0x9c,0xc3,0xb1,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,
0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0xf0,0x8b,0x23,0xe7,0x9c,0x73,0xce,0x3b,0xe7,
0x9c,0x73,0xde,0x39,0xe7,0x9c,0xf3,0xce,0x39,0xe7,0x1c,0x8e,0x9c,0x73,0xce,0x39,
0x87,0x23,0xe7,0x9c,0x73,0xce,0x79,0xe7,0x9c,0x73,0xce,0x3b,0xe7,0x9c,0x73,0xde,
0x39,0xe7,0x9c,0xf3,0xce,0x39,0xe7,0x9c,0x77,0xce,0x39,0xe7,0x70,0xe8,0x9c,0x73,
0xce,0x39,0xc7,0xef,0x9c,0x73,0xce,0x39,0x38,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,
0xe7,0x9c,0x73,0x0e,0x87,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x1c,0x1c,0x05
};
// bytes:336 ratio: 0.656

// cerberus.png  width: 64 height: 64
const PROGMEM uint8_t cerberus[] = {
0x3f,0x3f,0xe0,0x57,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0x7e,0xe7,
0x9c,0x73,0xce,0x39,0xf8,0xcd,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,
0x39,0xe7,0x9c,0x73,0xde,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,
0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0xc3,0x93,0x73,0xce,0x39,0x07,0x4f,0x39,0xe7,
0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0x78,0x72,0xce,0x39,0xe7,0x1c,0xfc,0x84,0x23,
0xe7,0x9c,0x73,0xce,0xe1,0x97,0xdf,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,
0x0e,0x87,0xce,0x39,0xe7,0x1c,0x9e,0x9c,0x73,0xce,0x39,0x1c,0x39,0xe7,0x9c,0x73,
0xce,0xe1,0x8f,0xdf,0x39,0xe7,0x9c,0x73,0x78,0x72,0xce,0x39,0xe7,0x70,0xe4,0x9c,
0x73,0xce,0x39,0xef,0x9c,0x73,0xce,0xe1,0xc9,0x39,0xe7,0x9c,0x73,0x38,0x74,0xce,
0x39,0xe7,0x1c,0x8e,0x9c,0x73,0xce,0x39,0x87,0x43,0xe7,0x9c,0x73,0xce,0xe1,0xcf,
0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0x38,0x76,0xce,0x39,0xe7,0x9c,0xc3,
0x91,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0x87,0x23,0x1c,0x39,0xe7,0x9c,0x73,
0x8e,0x1f,0x0e,0x72,0xce,0x39,0xe7,0xf0,0xe4,0x9c,0x73,0xce,0xe1,0x08,0x87,0xce,
0x39,0xe7,0x1c,0x0e,0x9d,0x73,0xce,0x39,0xe7,0xf0,0x8b,0x3f,0xe7,0x9c,0x73,0xce,
0xe1,0xc8,0x39,0xe7,0x9c,0x73,0x70,0x14,0x8e,0x9c,0x73,0xce,0x39,0xef,0x9c,0x73,
0xce,0x39,0xfc,0x03
};
// bytes:244 ratio: 0.477

const PROGMEM uint8_t cerberus_mask[] = {
0x3f,0x3f,0xe0,0x57,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0x7e,0xe7,
0x9c,0x73,0xce,0x39,0xf8,0xcd,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,
0x39,0xe7,0x9c,0x73,0xde,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,
0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0xc3,0x93,0x73,0xce,0x39,0x07,0x4f,0x39,0xe7,
0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0x78,0x72,0xce,0x39,0xe7,0x1c,0xfc,0x84,0x23,
0xe7,0x9c,0x73,0xce,0xe1,0x97,0xdf,0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,
0x0e,0x87,0xce,0x39,0xe7,0x1c,0x9e,0x9c,0x73,0xce,0x39,0x1c,0x39,0xe7,0x9c,0x73,
0xce,0xe1,0x8f,0xdf,0x39,0xe7,0x9c,0x73,0x78,0x72,0xce,0x39,0xe7,0x70,0xe4,0x9c,
0x73,0xce,0x39,0xef,0x9c,0x73,0xce,0xe1,0xc9,0x39,0xe7,0x9c,0x73,0x38,0x74,0xce,
0x39,0xe7,0x1c,0x8e,0x9c,0x73,0xce,0x39,0x87,0x43,0xe7,0x9c,0x73,0xce,0xe1,0xcf,
0x39,0xe7,0x9c,0x73,0xce,0x39,0xe7,0x9c,0x73,0x38,0x76,0xce,0x39,0xe7,0x9c,0xc3,
0x91,0x73,0xce,0x39,0xe7,0x9c,0x73,0xce,0x39,0x87,0x23,0x1c,0x39,0xe7,0x9c,0x73,
0x8e,0x1f,0x0e,0x72,0xce,0x39,0xe7,0xf0,0xe4,0x9c,0x73,0xce,0xe1,0x08,0x87,0xce,
0x39,0xe7,0x1c,0x0e,0x9d,0x73,0xce,0x39,0xe7,0xf0,0x8b,0x3f,0xe7,0x9c,0x73,0xce,
0xe1,0xc8,0x39,0xe7,0x9c,0x73,0x70,0x14,0x8e,0x9c,0x73,0xce,0x39,0xef,0x9c,0x73,
0xce,0x39,0xfc,0x03
};
// bytes:244 ratio: 0.477

// Game state
int gamestate = TITLE;
int prev_state = TITLE;
int pointer = 0;
int page = 0;
int scroll = 0;
bool scrolling = false;
bool theres_items = false;
int notif_counter = 0;
int frame_counter = 0;
long faith = 0L;
long resources[8] = {1L, 0L, 0L, 0L, 0L, 0L, 0L, 0L};
long prices[8] = {10L, 100L, 1000L, 10000L, 100000L, 1000000L, 10000000L, 100000000L};
const char* names[8] = {"Prayers", "Prophets", "Predicaments", "Sacred Writings", "Priests", "Temples", "Marthyrs", "Saints"};
char* notification;
bool random_arrows = false;
bool double_rate = false;
int  double_rate_countdown = 0;
int deity_fight = 0;
int thinking = 0;
bool defending = false;
long hp = 0;
long current_hp = 0;
long attack = 0;
long special = 0;
long enemy_hp = 0;
long current_enemy_hp = 0;
long enemy_attack = 0;
long enemy_special = 0;

// For saving and loading from EEPROM
typedef struct {
  long faith;

  long resources[8];
  long prices[8];
  int deity_fight;
} SaveGame;

// Classes
class FaithSprite {
  private:
    int x;
    int y;
    int velocity;
    int steps;

  public:
    FaithSprite() {
      this->x = 0;
      this->y = -20;
      this->velocity = 1;
      this->steps = 0;
    }

    void start(int x, int y) {
      this->x = x;
      this->y = y;
      this->velocity = 1;
      this->steps = 0;
    }

    void animate() {
      if (this->y > -16) {
        this->y = this->y - this->velocity;
        this->steps++;
        if (this->steps > 5) {
          this->steps = 0;
          this->velocity++;
        }
        arduboy.drawBitmap(this->x, this->y, faith_mask, 16, 16, BLACK);
        arduboy.drawBitmap(this->x, this->y, faith_image, 16, 16, WHITE);
      }
    }

    bool is_running() {
      return this->y > -16;
    }
};

class RandomArrow {
  private:
    int x;
    int y;
    int frame_counter;
    int arrow_direction;
    bool dir = false;

  public:
    RandomArrow() {
      this->x = 0;
      this->y = 0;
      this->frame_counter = 0;
    }
    
    void start(int x, int y, int arrow_direction) {
      this->frame_counter = 120;
      this->x = x;
      this->y = y;
      this->dir = false;
      this->arrow_direction = arrow_direction;
    }

    void animate() {
      if (this->frame_counter > 0) {
        this->frame_counter--;
        if (this->frame_counter % 5 == 0) {
          this->dir = !this->dir;
        }

        if (this->frame_counter % 2 == 0) {
          if (this->dir) {
            this->x++;
          } else {
            this->x--;
          }
        }

        switch (this->arrow_direction) {
          case ARROW_LEFT:
            arduboy.drawBitmap(this->x, this->y, arrow_left_mask, 8, 8, BLACK);
            arduboy.drawBitmap(this->x, this->y, arrow_left, 8, 8, WHITE);
            break;
          case ARROW_RIGHT:
            arduboy.drawBitmap(this->x, this->y, arrow_right_mask, 8, 8, BLACK);
            arduboy.drawBitmap(this->x, this->y, arrow_right, 8, 8, WHITE);
            break;
          case ARROW_DOWN:
            arduboy.drawBitmap(this->x, this->y, arrow_down_mask, 8, 8, BLACK);
            arduboy.drawBitmap(this->x, this->y, arrow_down, 8, 8, WHITE);
            break;
        }
      }
    }

    int running() {
      // Returns the arrow direction if it's running, else, returns -1
      if (this->frame_counter > 0) {
        return this->arrow_direction;
      }
      return -1;
    }

    void stop() {
      this->frame_counter = 0;
    }
};

FaithSprite faith_effects_manual[8];
FaithSprite faith_effects_auto[8];
RandomArrow random_arrow = RandomArrow();

// This function runs once in your game.
// use it for anything that needs to be set only once in your game.
void setup() {
  // initiate arduboy instance
  arduboy.begin();

  // here we set the framerate to 15, we do not need to run at
  // default 60 and it saves us battery life
  arduboy.setFrameRate(30);
  
  resetgame();    // Set initial state
}

void resetgame() {
  gamestate = TITLE;
  faith = 0L;
  pointer = 0;
  resources[0] = 1L;
  frame_counter = 0;
  scroll = 0;
  deity_fight = 0;
  long p = 100L;
  for (int c = 1; c < 8; c++) {
    resources[c] = 0L;
    prices[c] = p;
    p = p * 10L;
  }

  if (DEBUG) {
    resources[1] = 4;
    resources[2] = 1;
  }
  
  arduboy.initRandomSeed();
}

void resetbattle() {
  hp = 10;
  for (int c = 1; c < 8; c += 2) {
    hp += resources[c] * c * c;
  }
  current_hp = hp;

  for (int c = 2; c < 8; c += 2) {
    attack += resources[c] * c * 2;
  }

  special = resources[PRIESTS];

  if (special > 3) {
    special = 3;
  }

  enemy_hp = 10 + deity_fight * deity_fight * 10;
  current_enemy_hp = enemy_hp;
  enemy_attack = 1 + deity_fight * deity_fight;
  enemy_special = deity_fight - 5;
  if (enemy_special > 3) {
    enemy_special = 3;
  }
  thinking = 0;
}

void savegame() {
  SaveGame game;
  game.faith = faith;
  for (int c = 0; c < 8; c++) {
    game.resources[c] = resources[c];
    game.prices[c] = prices[c];
    game.deity_fight = deity_fight;
  }
  uint16_t address = EEPROM_STORAGE_SPACE_START + SAVEGAME_LOCATION;

  // Add a header so we know that the EEPROM contains a saved city
  EEPROM.update(address++, 'M'); 
  EEPROM.update(address++, 'C'); 
  EEPROM.update(address++, 'G'); 
  EEPROM.update(address++, 'D'); 

  uint8_t* ptr = (uint8_t*) &game;
  for(size_t n = 0; n < sizeof(SaveGame); n++)
  {
    EEPROM.update(address++, *ptr);
    ptr++;
  }
}

bool loadgame() {
  SaveGame game;
  
  uint16_t address = EEPROM_STORAGE_SPACE_START + SAVEGAME_LOCATION;

  if(EEPROM.read(address++) != 'M') return false;
  if(EEPROM.read(address++) != 'C') return false;
  if(EEPROM.read(address++) != 'G') return false;
  if(EEPROM.read(address++) != 'D') return false;

  uint8_t* ptr = (uint8_t*) &game;
  for(size_t n = 0; n < sizeof(SaveGame); n++)
  {
    *ptr = EEPROM.read(address++);
    ptr++;
  }

  faith = game.faith;
  deity_fight = game.deity_fight;

  for (int c = 0; c < 8; c++) {
    resources[c] = game.resources[c];
    prices[c] = game.prices[c];
  }

  return true;
}


// our main game loop, this runs once every cycle/frame.
// this is where our game logic goes.
void loop() {
  // pause render until it's time for the next frame
  if (!(arduboy.nextFrame())) {
    return;
  }

  // first we clear our screen to black
  arduboy.clear();

  // Game state loop
  switch (gamestate) {
    case TITLE:
      title();
      break;
      
    case PLAY:
      game_play();
      break;
      
    case GAMEMENU:
      game_menu();
      break;

    case FIGHT:
      fight_god();
      break;
      
    case NOTIFY:
      notify();
      break;

     case SAVEMENU:
      save_menu();
      break;
  }

  if (((gamestate != TITLE) && (gamestate != FIGHT)) &&
     (gamestate != SAVEMENU)){
    game_tick();
  }

  // then we finaly we tell the arduboy to display what we just wrote to the display
  arduboy.display();
}

void title() {
  // Write the title
  arduboy.setTextSize(2);
  arduboy.setCursor(2, 2);
  arduboy.print("Micro God");
  
  // Draw the menu
  font4x6.setCursor(70, 24);
  font4x6.print(F("New game"));
  font4x6.setCursor(70, 34);
  font4x6.print(F("Load game"));
  
  pointer = pointer % 2;
  
  if (pointer < 0) {
    pointer = 2;
  }
  
  switch (pointer) {
    case 0:
      arduboy.drawBitmap(61, 24, arrow_right, 8, 8);
      break;
    case 1:
      arduboy.drawBitmap(61, 34, arrow_right, 8, 8);
      break;
  }
  
  arduboy.pollButtons();
  
  if (arduboy.justPressed(UP_BUTTON)) {
    pointer--;
  }
  
  if (arduboy.justPressed(DOWN_BUTTON)) {
    pointer++;
  }
  
  if (arduboy.justPressed(A_BUTTON) || arduboy.justPressed(B_BUTTON)) {
    switch (pointer) {
      case 0:
        resetgame();
        gamestate = PLAY;
        break;
      case 1:
        load_game();
        break;
    }
  }
}

void load_game() {
  if (!loadgame()) {
    notification = "Could not load";
    prev_state = TITLE;
    gamestate = NOTIFY;
  } else {
    notification = "Loaded game";
    prev_state = PLAY;
    gamestate = NOTIFY;
  }
}

void save_menu() {
  // Write the title
  arduboy.setTextSize(2);
  arduboy.setCursor(2, 2);
  arduboy.print("Micro God");
  
  // Draw the menu
  font4x6.setCursor(50, 24);
  font4x6.print(F("Save game"));
  font4x6.setCursor(50, 34);
  font4x6.print(F("Fight god "));
  font4x6.print(deity_fight);
  font4x6.setCursor(50, 44);
  font4x6.print(F("End game"));
  font4x6.setCursor(50, 54);
  font4x6.print(F("Exit menu"));
  
  pointer = pointer % 4;
  
  if (pointer < 0) {
    pointer = 3;
  }
  
  switch (pointer) {
    case 0:
      arduboy.drawBitmap(41, 24, arrow_right, 8, 8);
      break;
    case 1:
      arduboy.drawBitmap(41, 34, arrow_right, 8, 8);
      break;
    case 2:
      arduboy.drawBitmap(41, 44, arrow_right, 8, 8);
      break;
    case 3:
      arduboy.drawBitmap(41, 54, arrow_right, 8, 8);
      break;
  }
  
  arduboy.pollButtons();
  
  if (arduboy.justPressed(UP_BUTTON)) {
    pointer--;
  }
  
  if (arduboy.justPressed(DOWN_BUTTON)) {
    pointer++;
  }
  
  if (arduboy.justPressed(A_BUTTON) || arduboy.justPressed(B_BUTTON)) {
    switch (pointer) {
      case 0:
        savegame();
        notification = "Game saved";
        prev_state = PLAY;
        gamestate = NOTIFY;
        break;
      case 1:
        // TODO: Fight against other gods
        if (resources[1] == 0 || resources[2] == 0) {
          notification = "Not enough power";
          prev_state = PLAY;
          gamestate = NOTIFY;
        } else {
          resetbattle();
          gamestate = FIGHT;
        }
        pointer = 0;
        break;
      case 2:
        resetgame();
        break;
      case 3:
        gamestate = PLAY;
        break;
    }
  }
}

void game_play() {
  random_arrow.animate();
  animate_faith();
  animate_items();
  
  arduboy.setTextSize(1);
  arduboy.setCursor(2, 2);
  if (double_rate) {
    arduboy.print(F("Faith(x3): "));
  } else {
    arduboy.print(F("Faith: "));  
  }
  
  arduboy.print(faith);

  font4x6.setCursor(2, 10);
  font4x6.print(F("Level "));
  font4x6.print(deity_fight);

  // Save menu indication
  font4x6.setCursor(12,55);
  font4x6.print(F("menu"));
  arduboy.drawBitmap(2,56, arrow_up_mask, 8, 8, BLACK);
  arduboy.drawBitmap(2,56, arrow_up, 8, 8, WHITE);

  // Buy menu indication
  font4x6.setCursor(102, 55);
  font4x6.print(F("B buy"));
  
  arduboy.pollButtons();
  if (arduboy.justPressed(A_BUTTON)) {
    long prayers = resources[PRAYERS];
    if (double_rate) {
      prayers = prayers * 3;
    }
    faith = faith + prayers;
    int effect = prayers / 8;
    if (effect == 0) {
      effect = 1;
    }

    if (effect > 8) {
      effect = 8;
    }
    add_faith_manual(effect);
  }
  
  if (arduboy.justPressed(B_BUTTON)) {
    gamestate = GAMEMENU;
  }

  if (arduboy.justPressed(UP_BUTTON)) {
    pointer = 0;
    gamestate = SAVEMENU;
  }

  if (arduboy.justPressed(LEFT_BUTTON) && random_arrow.running() == ARROW_LEFT) {
    double_rate = true;
    double_rate_countdown = DOUBLE_DURATION;
    random_arrow.stop();
  }

  if (arduboy.justPressed(RIGHT_BUTTON) && random_arrow.running() == ARROW_RIGHT) {
    double_rate = true;
    double_rate_countdown = DOUBLE_DURATION;
    random_arrow.stop();
  }

  if (arduboy.justPressed(DOWN_BUTTON) && random_arrow.running() == ARROW_DOWN) {
    double_rate = true;
    double_rate_countdown = DOUBLE_DURATION;
    random_arrow.stop();
  }
}

void add_faith_manual(int num) {
  int c = 0;
  while ((c < 8) && (num > 0)) {
    FaithSprite f = faith_effects_manual[c];
    if (!f.is_running()) {
      f.start(random(0, 116), random(30, 48));
      faith_effects_manual[c] = f;
      num--;
    }
    c++;
  }
}

void add_faith_auto(int num) {
  int c = 0;
  while ((c < 8) && (num > 0)) {
    FaithSprite f = faith_effects_auto[c];
    if (!f.is_running()) {
      f.start(random(0, 116), random(30, 48));
      num--;
      faith_effects_auto[c] = f;
    }
    num--;
    c++;
  }
}

void animate_faith() {
  int c;
  for (c = 0; c < 8; c++) {
    faith_effects_manual[c].animate();
  }
  for (c = 0; c < 8; c++) {
    faith_effects_auto[c].animate();
  }
}

void animate_items() {
  if (!theres_items) {
    // Check to see if we have items to show
    int sum = 0;
    for (int c=1; c < 8; c++) {
      sum = sum + resources[c];
    }

    theres_items = sum > 0;
  } else {
    if (!scrolling) {
      scroll = 127;
      scrolling = true;
    }
    bool drawn = false;
    int column = 0;
    int line = 0;
    for (int c=1; c < 8; c++) {
      int amount = resources[c];
      if (amount == 0) {
        continue;
      }
      int x = scroll;
      int currentx = x + (column * 8);
      if (currentx >= 128) {
        // Avoid drawing off screen
        continue;
      }
      for (int i=0; i < amount; i++) {
        draw_item(c, x + (column * 8), 46 - (line * 9));
        line++;
        if (line >= 3) {
          line = 0;
          column++;
        }
      }
      if (line != 0) {
        column++;
      }
      line = 0;
      if (x + (column * 8) <= -8) {
        drawn = false;
      } else {
        drawn = true;
      }
    }

    if (!drawn) {
      scrolling = false;    // Reset the scroll
    }
    scroll--;
  }
}

void draw_bar(int len, int x, int y) {
  for (int c=0; c<len; c++) {
    arduboy.drawBitmap(x + c, y, bar, 1, 6, WHITE);
  }
}

void draw_item(int item, int x, int y) {
  switch(item) {
    case PRAYERS:
      arduboy.drawBitmap(x, y, faith_small_mask, 8, 8, BLACK);
      arduboy.drawBitmap(x, y, faith_small_image, 8, 8, WHITE);
      break;
    case SACRED_WRITINGS:
      arduboy.drawBitmap(x, y, sacred_mask, 8, 8, BLACK);
      arduboy.drawBitmap(x, y, sacred_image, 8, 8, WHITE);
      break;
    case PREDICAMENTS:
      arduboy.drawBitmap(x, y, predicament_mask, 8, 8, BLACK);
      arduboy.drawBitmap(x, y, predicament_image, 8, 8, WHITE);
      break;
    case PRIESTS:
      arduboy.drawBitmap(x, y, priest_mask, 8, 8, BLACK);
      arduboy.drawBitmap(x, y, priest_image, 8, 8, WHITE);
      break;
    case PROPHETS:
      arduboy.drawBitmap(x, y, prophet_mask, 8, 8, BLACK);
      arduboy.drawBitmap(x, y, prophet_image, 8, 8, WHITE);
      break;
    case SAINTS:
      arduboy.drawBitmap(x, y, saint_mask, 8, 8, BLACK);
      arduboy.drawBitmap(x, y, saint_image, 8, 8, WHITE);
      break;
    case TEMPLES:
      arduboy.drawBitmap(x, y, temple_mask, 8, 8, BLACK);
      arduboy.drawBitmap(x, y, temple_image, 8, 8, WHITE);
      break;
    case MARTHYRS:
      arduboy.drawBitmap(x, y, marthyr_mask, 8, 8, BLACK);
      arduboy.drawBitmap(x, y, marthyr_image, 8, 8, WHITE);
      break;
  }
}

void draw_god(int god, int x, int y) {
  switch(god) {
    case 0:
      arduboy.drawCompressed(x, y, djinn_mask, BLACK);
      arduboy.drawCompressed(x, y, djinn, WHITE);
      break;
    case 1:
      arduboy.drawCompressed(x, y, cerberus_mask, BLACK);
      arduboy.drawCompressed(x, y, cerberus, WHITE);
      break;
    case 2:
      arduboy.drawCompressed(x, y, beholder_mask, BLACK);
      arduboy.drawCompressed(x, y, beholder, WHITE);
      break;
  }
}

void fight_god() {
  if (current_enemy_hp <= 0) {
      notification = "You win!";
      prev_state = PLAY;
      gamestate = NOTIFY;
      deity_fight++;
      thinking = 0;
      return;
    }

  if (current_hp <= 0) {
    notification = "You lose!";
    prev_state = PLAY;
    gamestate = NOTIFY;
    return;
  }
  
  draw_god(deity_fight % DEITIES, 64, 0);        // Increase by the number of sprites we can put

  // Our health bar
  font4x6.setCursor(2, 2);
  font4x6.print(F("HP "));
  draw_bar((current_hp * 40) / hp, 15, 3);

  // Enemy health bar
  font4x6.setCursor(2, 10);
  font4x6.print(F("EN "));
  draw_bar((current_enemy_hp * 40) / enemy_hp, 15, 11);

  if (thinking <= 0) {
    // Draw actions menu
    // Draw the menu
    font4x6.setCursor(12, 24);
    font4x6.print(F("Attack"));
    font4x6.setCursor(12, 34);
    font4x6.print(F("Defend"));
    font4x6.setCursor(12, 44);
    font4x6.print(F("Heal"));
    font4x6.setCursor(12, 54);
    font4x6.print(F("Specialx"));
    font4x6.print(special);
    
    switch (pointer) {
      case 0:
        arduboy.drawBitmap(2, 24, arrow_right, 8, 8);
        break;
      case 1:
        arduboy.drawBitmap(2, 34, arrow_right, 8, 8);
        break;
      case 2:
        arduboy.drawBitmap(2, 44, arrow_right, 8, 8);
        break;
      case 3:
        arduboy.drawBitmap(2, 54, arrow_right, 8, 8);
        break;
    }
  
    arduboy.pollButtons();
  
    if (arduboy.justPressed(UP_BUTTON)) {
      pointer--;
    }
  
    if (arduboy.justPressed(DOWN_BUTTON)) {
      pointer++;
    }
    
    pointer = pointer % 4;
    
    if (pointer < 0) {
      pointer = 3;
    }
  
    if (arduboy.justPressed(A_BUTTON) || arduboy.justPressed(B_BUTTON)) {
      switch (pointer) {
        case 0:
          // ATTACK
          if (do_attack(true)) {
            notification = "Attack successful!";
          } else {
            notification = "Attack failed!";  
          }
          break;
        case 1:
          // DEFEND
          defending = true;
          notification = "Defense";
          break;
        case 2:
          // HEAL
          if (current_hp < hp) {
            if (hp / 10 == 0) {
              current_hp++;
            } else {
              current_hp += hp / 10;
            }
          }
          if (current_hp > hp) {
            current_hp = hp;
          }
          notification = "Healing";
          break;
        case 3:
          // SPECIAL
          if (special > 0) {
            current_enemy_hp -= attack * 3;
            special--;
            notification = "Special attack";
          } else {
            if (do_attack(true)) {
              notification = "Normal attack";
            } else {
              notification = "Failed attack";
            }
          }
          break;
      }
      prev_state = FIGHT;
      gamestate = NOTIFY;
      thinking = 30;
    }
  } else {
    if (thinking == 1) {
      // DO ENEMY TURN
      int action = random(0, 6);
      if (action == 0) {
        current_enemy_hp += enemy_hp / 10;
        if (current_enemy_hp > enemy_hp) {
          current_enemy_hp = enemy_hp;
        }
        notification = "Enemy heals";
      } else if ((action > 0) && (action < 5)) {
        if (do_attack(false)) {
          if (!defending) {
            current_hp -= enemy_attack;
          } else {
            current_hp -= enemy_attack / 4;
          }
          notification = "Enemy hits!";
        } else {
          notification = "Enemy missed!";
        }
      } else if (action == 5) {
        if (enemy_special > 0) {
          current_hp -= enemy_attack * 3;
          notification = "Enemy special!!";
        } else {
          notification = "Enemy failed!";
        }
      }
      prev_state = FIGHT;
      gamestate = NOTIFY;
      thinking = 0;
    }
    thinking--;
  }
}

bool do_attack(bool player) {
  if (player) {
    int dice = random(0, attack);
    if (dice < (attack - (deity_fight + 1))) {
      current_enemy_hp -= attack;
      return true;
    }
    return false;
  } else {
    int dice = random(0, enemy_attack);
    if (dice < (enemy_attack - (hp / 10))) {
      current_hp -= enemy_attack;
      return true;
    }
    return false;
  }
}

void game_menu() {
  int x = 20;
  int y = 10;

  pointer = pointer % 8;
  if (pointer < 0) {
    pointer = 7;
  }

  if (pointer < 5) {
    page = 1;
  } else {
    page = 2;
  }

  font4x6.setCursor(2, 2);
  font4x6.print(F("Price: "));
  font4x6.print(prices[pointer]);

  if (page == 1) {
    for (int c = 0; c < 5; c++) {
      font4x6.setCursor(x, y + (c * 10));
      font4x6.print(names[c]);
      font4x6.print(F(": "));
      font4x6.print(resources[c]);
      draw_item(c, x - 9, y + (c * 10));
    }
    font4x6.setCursor(100, 56);
    font4x6.print(F("More..."));
  } else {
    for (int c = 5; c < 8; c++) {
      font4x6.setCursor(x, y + ((c - 5) * 10));
      font4x6.print(names[c]);
      font4x6.print(F(": "));
      font4x6.print(resources[c]);
      draw_item(c, x - 9, y + ((c - 5) * 10));
    }
  }

  if (pointer < 5) {
    arduboy.drawBitmap(2, y + (10 * pointer), arrow_right, 8, 8);
  } else {
    arduboy.drawBitmap(2, y + (10 * (pointer - 5)), arrow_right, 8, 8);
  }
  
  arduboy.pollButtons();

  if (arduboy.justPressed(UP_BUTTON)) {
    pointer--;
  }

  if (arduboy.justPressed(DOWN_BUTTON)) {
    pointer++;
  }

  if (arduboy.justPressed(A_BUTTON)) {
    if (faith >= prices[pointer]) {
      faith -= prices[pointer];
      resources[pointer] = resources[pointer] + 1;
      prices[pointer] = prices[pointer] + (prices[pointer] / 2);
      notification = "Acquired!";
      prev_state = PLAY;
      gamestate = NOTIFY;
    } else {
      notification = "Not Enough Faith!";
      prev_state = GAMEMENU;
      gamestate = NOTIFY;
    }
  }
  
  if (arduboy.justPressed(B_BUTTON)) {
    gamestate = PLAY;
  }
}

void notify() {
  // Write the notification
  arduboy.setTextSize(1);
  arduboy.setCursor(2, 2);
  arduboy.print(notification);

  notif_counter++;

  if (notif_counter >= NOTIFICATION_DURATION) {
    gamestate = prev_state;
    notif_counter = 0;
  }

  arduboy.pollButtons();

  if ((arduboy.justPressed(A_BUTTON)) || (arduboy.justPressed(B_BUTTON))) {
    gamestate = prev_state;
    notif_counter = 0;
  }
}

void game_tick() {
  frame_counter++;

  if (frame_counter > 6) {
    // Game tick elapsed, parse the resources and add accordingly
    // except the prayers, those are only for clicks
    int delta = 0;
    for (int c = 1; c < 8; c++) {
      int res = resources[c];
      delta += res * (c * c);
    }

    if (double_rate) {
      delta = delta * 3;
      double_rate_countdown--;

      if (double_rate_countdown <= 0) {
        double_rate = false;
      }
    }
    // Add the amount generated by auto resources
    faith += delta;

    // Calculate the amount of faith effect to create
    if (delta > 0) {
      random_arrows = delta >= 80;    // Random arrows appear at this level
      delta = (delta / 80) + 1;
      if (delta > 8) {
        delta = 8;
      }
      add_faith_auto(delta);
    }
    frame_counter = 0;

    if (random_arrow.running() < 0 && !double_rate) {
      if (random_arrows && random(0, 100) > 98) {
        int dir;
        switch (random(0,3)) {
          case 0:
            dir = ARROW_LEFT;
            break;
          case 1:
            dir = ARROW_RIGHT;
            break;
          case 2:
            dir = ARROW_DOWN;
            break;
        }
        random_arrow.start(random(0, 120), random(12, 76), dir);
      }
    }
  }
}
